\section{交互式协议：基本表记}

在具体介绍身份识别协议之前，我们首先需要准确定义\textbf{交互式协议 (interactive protocol)}。

一个交互式协议可以在任意数量的参与方之间进行，但在本文中我们主要关注两方协议。不管有多少参与方，一个协议都可以运行很多次。我们把每一次协议的运行称为\textbf{协议实例(protocol instance)}。

在任意一个协议实例中，每一方都会从初始化设置开始。随着协议的运行，各参与方会发送和接收消息，并更新其本地设置。尽管具体细节因协议不同而各异，但是我们可以使用一个\textbf{交互式协议算法}来对协议实例中各方的计算进行建模。这种算法是一个概率性算法 $I$，它接收元组 $({config}_\mathrm{old}, {data}_\mathrm{in})$ 作为输入，并输出一个新元组 $({config}_\mathrm{new}, {data}_\mathrm{out})$。当某一方开始执行一个协议实例时，它首先需要提供一个\textbf{输入值}，这个输入值用于对该参与方的协议实例进行\textbf{初始化设置 (initial configuration)}。当该参与方从网络中收到一个新的消息时，它会调用算法 $I$ 并输入 $({config}_\mathrm{old}, {data}_\mathrm{in})$，其中 ${config}_\mathrm{old}$ 是该方先前的状态，${data}_\mathrm{in}$ 是接收到的消息；$I$ 将会输出元组 $({config}_\mathrm{new}, {data}_\mathrm{out})$，其中 ${config}_\mathrm{new}$ 是该方新的状态，${data}_\mathrm{out}$ 是发出的消息。该方会通过传输信道发送消息给协议的另一参与方。根据协议的要求，上述过程会被反复执行若干次，直到达到某个\textbf{终止设置 (terminal configuration)}。这种终止配置可以指定一个\textbf{输出值}，该输出值可以被
该方使用，比如说用于一些更高层的协议中。

一般来说，一个参与方可能会运行多个协议，或同一协议的多个实例。所有这些不同的协议实例的设置都需要单独维护。

\subsection{数学细节}

像往常一样，我们可以使用第2.3节中定义的术语更精确地定义上述概念。除了上面定义的输入，交互式协议算法 $I$ 还会接受一个安全参数 $\lambda$ 和系统参数 $\Lambda$ 作为输入。然而有几个细节值得讨论。

简单起见，我们可以认为一个运行中的协议实例的设置规模是多项式边界的。也就是说，我们可以将设置为一个比特序列，且该序列的长度总是以固定的 $\lambda$ 的多项式为界。这使得我们可以将定义2.8应用于算法$I$。同样，该定义也要求算法的任何输入也同样应是多项式边界的。因此，对于任何多项式边界的输入，算法$I$的输出也同样是多项式边界的。

我们在这里试图解决的问题如下。假设在每一轮之后，设置的大小会增加一倍。几轮之后，设置的大小将会指数爆炸，尽管在每一轮中，计算的时间与当前配置大小成多项式关系。通过坚持要求状态的大小满足多项式边界，我们就可以避免出现指数爆炸的情况。

简单起见，我们还需要坚持协议的轮复杂度 (round complexity)也是多项式边界的。我们主要对执行恒定轮数的协议感兴趣。更一般地，我们希望协议的轮复杂度也是由 $\lambda$ 的固定多项式来约束。这可以通过要求从任何初始配置开始，$I$ 经过多轮迭代后必然达到一个最终状态来实现。