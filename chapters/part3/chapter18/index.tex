\chapter{用于身份识别与认证的协议}

在这一部分，我们关注身份认证和登录问题。考虑甲方希望向乙方表明自己的身份以获取乙方提供的可用资源。他们使用身份识别协议来实现这一目的。识别协议是密码学提供的基本工具之一。我们下面给出几个具体应用场景作为说明，旨在为读者建立一个直观的理解。

\emph{打开一把门锁}。Alice 想通过数字门锁的身份识别，以打开门锁并进入房间。Alice 可以使用一个简单的口令系统，她将电子钥匙插入门锁，如果这个钥匙提供了一个有效的口令，门锁就会打开。与这个场景类似的场景是电脑或者手机上的本地登录界面，当 Alice 想要向设备表明身份来获取访问权时，她可以使用口令来解锁电脑或者手机。

\emph{解锁汽车}。Alice 想要用一个无线硬件钥匙来解锁她的智能汽车，这把钥匙扣能与汽车互动。对手可以窃听无线电信道并记录钥匙扣与汽车之间的一次或若干次通信。尽管如此，对手仍然无法通过这种\emph{窃听攻击}解锁汽车。

\emph{登录银行自动取款机}。Alice 想要使用 ATM 机从自己的账户中提取现金。问题是，她可能正在与一台假的 ATM 机交互。一份来自某个大型ATM设备提供商的报告显示，假 ATM 机正在成为银行业的一个重大威胁：
\begin{quote}
早在 1993 年，就有犯罪团伙在曼彻斯特的一个购物中心安装了一台假的自动柜员机。这种假机器的设计目的并不是直接偷钱，而是在顾客面前假装不能正常工作，同时从试图使用的顾客那里窃取银行卡的信息。
\end{quote}
使用这样的一个假的ATM机，对手就可以与Alice交互并试图窃取她的凭证，并在之后使用该凭证来假冒Alice进行认证。我们称这种对手为\emph{主动}对手。我们的目标是设计识别协议，确保即使是这种主动对手也无法攻破安全系统。

\emph{登录到一个在线银行账户}。Alice 想要访问她的在线银行账户。她的浏览器首先与银行建立了一个安全信道。随后 Alice 通过安全信道运行一个身份识别协议向银行证明自己的身份，比如使用口令，就像之前的例子一样。问题是对手同样可以克隆一个银行的网站来欺骗 Alice，这样 Alice 就会向对手的网站提供自己的信息。这种攻击被称为\textbf{网络钓鱼(phishing)}，它是另一个主动攻击的典型例子，对手在与 Alice 交互的过程中扮演一个积极的角色。


对手试图窃取她的凭证，以便以后可以将凭证卖给任何希望冒充 Alice 到真正银行的人。同样，我们的目标是确保即使是网络钓鱼的对手也无法得知 Alice 的有效凭证。我们将在第21.11.1节中更详细地讨论网络钓鱼攻击，并介绍一种潜在的密码学防御手段。

\begin{snote}[身份识别协议 (Identification protocols)。]
身份识别协议在上述所有的场景中都会用到。抽象地讲，身份识别问题涉及到两方，即一个\textbf{证明者 (prover)} 和一个\textbf{验证者(verifier)}。

比如说在ATM的例子中，Alice扮演证明者的角色，而ATM机则扮演验证者的角色。证明者有一个\textbf{证明私钥}$sk$，它能用来说服验证者相信自己的身份。而验证者有一个相应的\textbf{验证密钥}$vk$，它能用来确认证明者的声称。我们有时会把证明者称为人类用户，把验证者称为计算机或服务器。

上面的几个例子也揭示了身份识别协议的三种攻击模型，我们将在接下来的章节中详细讨论这些模型：

\begin{itemize}
    \item \textbf{直接攻击}：门锁和本地登录的例子描述了物理距离上接近的证明者和验证者之间的交互。如果对手无法窃听到交互的内容，那么除了公开的信息之外，对手无法得到任何其他的有效信息，因此对手必须以某种方式在验证者面前冒充证明者。一个简单的口令协议就足以抵御这种直接攻击。
    \item \textbf{窃听攻击}：在无线汽车钥匙的例子中，对手可以窃听无线电信道并获得证明者和验证者之间的若干次交互记录。在这种情况下，简单的口令协议也是不安全的。但是稍微复杂一点的一次性口令协议就能够保证安全。
    \item \textbf{主动攻击}：最后两个例子，也就是假ATM机和假的网上银行，展示了一个更加积极主动的对手。对手在这种场合中试图主动学习一些信息，让它能够在以后的验证过程中冒充证明者。抵御这种主动攻击的身份识别协议往往需要在证明者和验证者之间进行多次交互，我们通常把这种技术称为挑战-应答。
\end{itemize}

当Alice试图登录一台已受感染的计算机时，发生的攻击也属于主动攻击。感染计算机的恶意软件可以展示一个假的登录界面并欺骗Alice与之交互，从而发动主动攻击。以这种方式窃取用户口令的恶意软件被称为\textbf{木马(Trojan horse)}。被盗的口令可以用来冒充Alice登入其他设备。	
\end{snote}

\begin{snote}[验证密钥的保密与公开.]
在一些身份识别协议中，验证者必须将其验证密钥 $vk$ 保密，而另一些协议允许 $vk$ 公开。显然，可以公开 $vk$ 的协议更具优势，因为在这种协议中，即使验证者（比如 ATM 机）被攻破，也不会造成任何损害。
\end{snote}

\begin{snote}[无状态协议与有状态协议.]
理想情况下，在协议设置阶段之后，$vk$和$sk$的值就不会再被修改。但是在某些协议中，$vk$ 和 $sk$ 的值在每次协议执行时都会更新，其中证明者更新 $sk$，验证者更新 $vk$。我们称 $vk$ 和 $sk$ 永远固定的协议为\textbf{无状态}协议，而 $vk$ 和 $sk$ 会被更新的协议为\textbf{有状态}协议。一些有状态协议能够比无状态协议以更低的成本提供更高的安全性。但是有状态协议往往更难使用，因为证明者和验证者需要始终保持正确同步。
\end{snote}

\begin{snote}[单向证明与相互识别.]
在本章中，我们只研究单向的识别问题，即 Bob 希望验证 Alice 的身份。与此相关的另一个话题是\textbf{相互识别}，即 Bob 同样也要向 Alice 证明自己的身份。我们将在第21章探讨这部分内容，届时我们会构造能够生成一个共享密钥的相互识别协议。
\end{snote}

\begin{snote}[身份识别协议的安全性和局限性.]
识别协议是为了防止对手在没有 Alice 协助的情况下仿冒 Alice。在定义身份识别协议的安全性时，我们可以允许对手窃听协议通信，甚至直接与 Alice 进行交互。但是，当对手开始尝试冒充 Alice 时，它必须在不与 Alice 通信的情况下进行。在上面的例子里，比如打开门锁的场景，我们给出了一些设定，主要目标就是在Alice不在的时候防止冒充。

然而，身份识别协议并不足以在Alice和远程的参与方（比如Alice的银行）之间建立安全会话。问题在于，身份识别协议很容易受到中间人(MiTM)攻击。假设Alice通过一个不安全的信道与她的银行执行一个身份识别协议，那么如果对手控制了信道，它就可以随意阻止或注入信息。对手等待Alice与她的银行运行识别协议，并将所有协议信息从一方转发到另一方。一旦协议成功完成，对手就可以向银行发送请求，这些请求似乎来自Alice，因此银行会尊重这些请求。实际上，对手利用Alice向银行进行身份验证，然后劫持会话以向银行发送自己的信息。

为了抵抗MiTM攻击，我们可以把识别协议和会话密钥交换协议结合起来，正如我们将在第21章讨论的那样。在Alice和她的银行之间共享会话密钥可以防止对手仿冒Alice注入消息。	
\end{snote}

\input{chapters/part3/chapter18/section1}
\input{chapters/part3/chapter18/section2}
\input{chapters/part3/chapter18/section3}
\input{chapters/part3/chapter18/section4}
\input{chapters/part3/chapter18/section5}
\input{chapters/part3/chapter18/section6}
\input{chapters/part3/chapter18/section7}
\input{chapters/part3/chapter18/section8}
\input{chapters/part3/chapter18/section9}
\input{chapters/part3/chapter18/section10}