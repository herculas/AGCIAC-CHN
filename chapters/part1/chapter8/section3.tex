\section{针对抗碰撞哈希函数的生日攻击}\label{sec:8-3}

当输出的摘要长度比较短时，密码学哈希函数是最有用的。挑战在于，设计一个输出尽可能短，但又很难找到碰撞的哈希函数是很难的。直观地讲，摘要越短，攻击者显然就越容易找到碰撞。为了说明这一点，考虑一个哈希函数 $H$，它输出 $\ell$ 比特的摘要，其中的 $\ell$ 是某个小的整数。显然，攻击者最多只要计算 $2^\ell+1$ 条不同消息的哈希，就很容易找到两条摘要相同的消息，进而打破 $H$ 的抗碰撞性。因此，输出较短（比如 $16$ 比特长）摘要的哈希函数是无法抗碰撞的：我们只需要计算 $2^{16}+1$ 次哈希，就必定能够找到碰撞。

\begin{snote}[生日攻击。]
利用附录 \ref{sec:B-1} 节中介绍的生日悖论，我们可以构造一种更具破坏性的攻击。令 $H$ 是一个定义在 $(\mathcal{M},\mathcal{T})$ 上的哈希函数，并置 $N:=|\mathcal{T}|$。对于标准的哈希函数，$N$ 是相当大的，比如说，在 SHA256 中，$N=2^{256}$。在本节中，我们假设 $\mathcal{M}$ 的大小至少是 $100N$。这基本上意味着被哈希的消息稍稍长于输出摘要。下面，我们介绍一个通用的碰撞发现者，它可以在对 $H$ 进行 $O(\sqrt{N})$ 次预期评估后找到 $H$ 的碰撞。作为对比，上面的暴力攻击需要 $O(N)$ 次评估。这个更有效的碰撞发现者将迫使我们将摘要设置成远长于现在的状态。

$H$ 的生日碰撞发现者的工作原理如下：它随机选取 $s\approx\sqrt{N}$ 条相互独立的消息 $m_1,\dots,m_s\overset{\rm R}\leftarrow\mathcal{M}$，并寻找这 $s$ 条消息之中的碰撞。我们将证明，生日悖论意味着，这些消息之间很可能存在碰撞。更确切地说，生日碰撞发现者的工作原理如下：

\vspace{5pt}

\hspace*{5pt}算法 \texttt{BirthdayAttack}：

\vspace{5pt}

\hspace*{28.5pt} 1.\quad 置$s\leftarrow\lceil 2\sqrt{N}\rceil+1$\\
\hspace*{50pt} 2.\quad 随机均匀地生成 $s$ 条 $\mathcal{M}$ 上的消息 $m_1,\dots,m_s$\\
\hspace*{50pt} 3.\quad 对于所有的 $i=1,\dots,s$，计算 $x_i\leftarrow H(m_i)$\\
\hspace*{50pt} 4.\quad 寻找互不相同的 $i,j\in\{1,\dots,s\}$ 使得 $H(m_i)=H(m_j)$\\
\hspace*{50pt} 5.\quad 如果存在这样的 $i,j$，并且 $m_i\neq m_j$：\\
\hspace*{50pt} 6.\quad\quad\quad 输出数对 $(m_i,m_j)$

\vspace{5pt}

\noindent
我们声称，如果对手随机选取了 $s:=\lceil 2\sqrt{N}\rceil+1$ 条 $\mathcal{M}$ 上的消息，那么存在互不相同的 $i,j$ 使得 $H(m_i)=H(m_j)$ 且 $m_i\neq m_j$ 的概率至少是 $1/2$。这意味着该算法能以至少 $1/2$ 的概率输出一个碰撞。
\end{snote}

\begin{lemma}\label{lemma:8-2}
令 $m_1,\dots,m_s$ 是步骤 2 中采样的随机消息。假设 $|\mathcal{M}|\geq100N$。那么 $\{1,\dots,s\}$ 中存在 $i,j$ 使得 $H(m_i)=H(m_j)$ 且 $m_i\neq m_j$ 的概率至少是 $1/2$。
\end{lemma}

\begin{proof}
对于 $i=1,\dots,s$，令 $x_i:=H(m_i)$。首先，我们论证其中两个 $x_i$ 值将以至少 $3/4$ 的概率发生碰撞。如果 $x_i$ 均匀分布在 $\mathcal{T}$ 上，那么根据定理 \ref{theo:B-1} 的第 (i) 部分，我们可以立即证明这一声称。事实上，如果 $x_i$ 独立且均匀地分布在 $\mathcal{T}$ 上，那么 $x_i$ 间的碰撞发生的概率至少是 $1-e^{-s(s-1)/2N}\geq1-e^{-2}\geq3/4$。

然而，在现实中，函数 $H(\cdot)$ 可能会使输出分布出现偏差。即使 $m_i$ 是从 $\mathcal{M}$ 中均匀采样来的，但得到的 $x_i$ 在 $\mathcal{T}$ 中可能并不均匀。作为一个简单的例子，考虑一个输出的摘要只在 $\mathcal{T}$ 的某个小子集中的哈希函数 $H(\cdot)$。由此产生的 $x_i$ 肯定不会均匀分布在 $\mathcal{T}$ 上。幸运的是（对攻击者来说），推论 \ref{cor:B-2} 表明，非均匀的 $x_i$ 只会增加碰撞的概率。由于 $x_i$ 是独立同分布的，该推论意味着 $x_i$ 间的碰撞将以至少 $1-e^{-s(s-1)/2N}\geq3/4$ 的概率发生，这与声称相符。

下面我们论证，$x_i$ 间的碰撞很可能导致 $H(\cdot)$ 上的碰撞。假设$\{1,\dots,s\}$中存在某两个互不相同的 $i,j$ 使得$x_i=x_j$。因为 $x_i=H(m_i)$，$x_j=H(m_j)$，所以数对 $m_i,m_j$ 就是一个潜在的 $H(\cdot)$ 上的碰撞。我们只需要论证 $m_i\neq m_j$ 即可。为此，我们论证所有的 $m_1,\dots,m_s$ 都互不相同的概率至少是 $4/5$。这可以直接由定理 \ref{theo:B-1} 的第 (ii) 部分得到。回顾一下，我们要求 $\mathcal{M}$ 是大于 $100N$ 的。由于 $m_1, m_2,\dots$ 均匀且互相独立地分布在 $\mathcal{M}$ 上，并且 $s<|\mathcal{M}|/2$，那么定理 \ref{theo:B-1} 的第 (i) 部分意味着，这些 $x_i$ 发生碰撞的概率最多为 $1-e^{-s(s-1)/100N}\leq 1/5$。因此不发生碰撞的概率至少是 $4/5$。

总之，对于试图找到 $H(\cdot)$ 上碰撞的算法，只需要保证 $x_i$ 间发生碰撞，同时 $m_i$ 间不发生碰撞。这发生的概率至少是$3/4-1/5>1/2$，与定理的要求相符。
\end{proof}

\begin{snote}[变体。]
算法 \texttt{BirthdayAttack} 需要 $O(\sqrt{N})$ 级别的内存空间，这可能相当大，甚至比消费级的磁盘农场还要大。然而，练习 \ref{exer:8-8} 描述了一个改进后的生日碰撞发现者，它能用 $4\sqrt{N}$ 次预期的哈希函数计算和\emph{常数级}的内存空间找到碰撞。

如果只对 $H(\cdot)$ 进行少于 $N$ 次的查询，生日攻击就有可能失败。假设我们只对 $H(\cdot)$ 进行了 $s=\epsilon\sqrt{N}$ 次查询，其中 $\epsilon\in[0,1]$ 是一个小数。简单起见，我们假设 $H(\cdot)$ 输出的摘要均匀分布在 $\mathcal{T}$ 上。那么定理 \ref{theo:B-1} 的第 (ii) 部分表明，发现碰撞的概率将以指数级下降到大约为 $1-e^{-(\epsilon^2)}\approx\epsilon^2$。

换句话说，在计算 $s$ 次哈希函数后，如果对手想要以最大 $\delta$ 的概率得到一个碰撞，那么摘要空间 $\mathcal{T}$ 就必须满足 $|\mathcal{T}|\geq s^2/\delta$。比如说，如果对手在对 $H$ 进行 $2^80$ 次评估后，要以最多 $2^{-80}$ 的概率发现碰撞，那么摘要长度就必须至少是 $240$ 比特。密码学哈希函数，比如 SHA256，输出 $256$ 比特的摘要。其他的哈希函数，比如 SHA384 和 SHA512，会输出更长的摘要，分别是 $384$ 比特和 $512$ 比特。
\end{snote}