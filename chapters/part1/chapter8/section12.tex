\section{一个有趣的应用：承诺与拍卖}\label{sec:8-12}

Alice 和 Bob 决定和其他竞拍者一起参加一个稀有瓷器花瓶的拍卖。拍卖行采用\textbf{Vickrey 密封投标拍卖(Vickrey sealed bid auction)}，这是一种很常见的拍卖机制，其工作原理如下：每个竞拍者都为花瓶提交一个机密且密封的投标。一旦所有的竞拍者都给出了报价，报价最高的一方就能得到花瓶，而它需要支付的价格就是第二高的报价。假设参与者不会互相串通，并且在拍卖结束之前无法获知其他方的报价，我们就可以证明这种拍卖机制具备良好的博弈论属性。因此，密封投标拍卖正是我们所需要的。

当所有的参与者都在同一个房间里时，拍卖行可以让每个参与者都准备一个密封的信封，并在其中提交它们的报价，以此实现 Vickrey 拍卖。收集完所有的信封后，拍卖师就可以打开信封并宣布结果。竞拍者可以检查信封和其中的文件，以验证拍卖是否正确地进行。在这个过程中，拍卖行不需要是可信的。

让我们看看，当竞拍者都在远程参与竞拍，并通过互联网与拍卖行进行通信时，我们怎样实现密封投标拍卖。我们使用加密承诺来实现这一目标，它是一个重要的密码学原语，有很多的应用。我们之前在 \ref{sec:3-12} 节中介绍过密码学承诺，在那里，我们将其用于两方之间的一个抛硬币协议。

回顾一下，一个承诺方案 $\mathcal{C}$ 让其中一方 Alice 发布一个承诺序列 $c$ 以承诺一条消息 $m\in\mathcal{M}$。之后，Alice 可以打开承诺并说服另一方 Bob，她所承诺的消息是 $m$。更确切地说，一个有限消息空间 $\mathcal{M}$ 上的承诺方案是一对有效算法 $\mathcal{C}=(C,V)$，其中：
\begin{itemize}
	\item 算法 $C$ 的调用方式是 $(c,o)\overset{\rm R}\leftarrow C(m)$，其中 $m\in\mathcal{M}$ 是要承诺的消息，$c$ 是承诺序列，$o$ 是打开序列。
	\item 算法 $V$ 是一个确定性的算法，它的调用方式是 $V(m,c,o)$，输出 $\mathsf{accept}$ 或 $\mathsf{reject}$。
	\item 正确性属性：对于所有的 $m\in\mathcal{M}$，如果 $(c,o)\overset{\rm R}\leftarrow C(m)$，则有 $\Pr[V(m,c,o)=\mathsf{accept}]=1$。
\end{itemize}
Alice 通过计算 $(c,o)\overset{\rm R}\leftarrow C(m)$ 来承诺一条消息 $m\in\mathcal{M}$。她把承诺 $c$ 发送给 Bob，并自己保留 $o$。之后，当 Alice 想打开承诺时，她就把 $m$ 和 $o$ 发送给Bob，而 Bob 通过运行 $V(m,c,o)$ 来验证承诺是否被正确地打开。

承诺方案 $\mathcal{C}$ 旨在成为密封信封在数字世界的一种类比。因此，它需要满足以下两个属性：
\begin{itemize}
	\item \textbf{绑定(binding)：}一旦产生了承诺 $\mathcal{C}$，Alice 就只能将其打开到单一的一条消息。特别地，对于每一个输出五元组 $(c,m_1,o_1,m_2,o_2)$ 的有效对手 $\mathcal{A}$，它的优势：
	\[
	\mathrm{BIND}\mathsf{adv}[\mathcal{A},\mathcal{C}]:=
	\Pr\big[m_1\neq m_2\land V(m_1,c,o_1)=V(m_2,c,o_2)=\mathsf{accept}\big]
	\]
	是可忽略不计的。
	\item \textbf{隐藏(hiding)：}承诺序列 $c$ 不应透露任何关于承诺消息 $m\in\mathcal{M}$ 的信息。我们使用语义安全性的定义来捕捉这一点。具体来说，定义两个在对手 $\mathcal{A}$ 和挑战者之间进行的实验，实验 $0$ 和实验 $1$。对于 $b=0,1$，在实验 $b$ 中，对手 $\mathcal{A}$ 首先输出 $m_0,m_1\in\mathcal{M}$。然后，挑战者计算 $(c,o)\overset{\rm R}\leftarrow C(m)$，并将 $c$ 发送给 $\mathcal{A}$。最后，$\mathcal{A}$ 输出一个猜测 $\hat{b}\in\{0,1\}$。对于 $b=0,1$，令 $W_b$ 为 $\mathcal{A}$ 在实验 $b$ 中输出 $1$ 的事件。我们要求，对于所有有效对手 $\mathcal{A}$，优势：
	\[
	\mathrm{HID}\mathsf{adv}[\mathcal{A},\mathcal{C}]:=
	\Big\lvert
	\Pr[W_0]-\Pr[W_1]
	\Big\rvert
	\]
	是可忽略不计的。
\end{itemize}

\begin{definition}\label{def:8-8}
如果一个承诺方案 $\mathcal{C}=(C,V)$ 既是隐藏的又是绑定的，它就是安全的。
\end{definition}

\begin{remark}[加密可能是非绑定的]\label{remark:8-1}
我们可能倾向于使用加密来实现一个承诺方案。令 $(E,D)$ 是一个语义安全的密码，其密钥空间为 $\mathcal{K}$，消息空间为 $\mathcal{M}$。由该密码派生而来的承诺方案 $(C,V)$ 的工作原理如下：$C(m)$ 随机选择一个密钥 $k\overset{\rm R}\leftarrow\mathcal{K}$，计算 $c\overset{\rm R}\leftarrow E(k,m)$，并输出 $(c,k)$ 作为承诺和打开序列。如果$D(k,c)=m$，算法 $V(m,c,k)$ 就接受该承诺。

乍一看，这似乎是一个良好的承诺方案。然而，这种构造可能完全是不安全的，这也是现实世界里实现错误的一个常见来源。让我们来看看原因。这个承诺方案显然是隐藏的，因为密码是语义安全的。所以问题并不在这里。然而，该方案可能不是绑定的，这就破坏了安全性。问题在于，我们可能找到一个承诺序列 $c$ 和两个密钥 $k_1$ 和 $k_2$，使得 $D(k_1,c)\neq D(k_2,c)$，而两个解密都在 $\mathcal{M}$ 上。这并不会影响密码的安全性，但能够让攻击者将承诺 $c$ 打开到两条不同消息上，这就破坏了绑定属性。这表明，加密和承诺虽然相关，但却是完全不同的对象。

比如说，假设 $\mathcal{M}=\mathcal{K}=\{0,1\}^n$，并且 $(E,D)$ 是一个一次性密码本。那么对消息 $m\in\mathcal{M}$ 的承诺就是简单的 $c=m\oplus k$，其中 $k\overset{\rm R}\leftarrow\mathcal{K}$。现在，承诺者很容易将这个承诺 $c$ 打开到它所选择的任意一条 $\mathcal{M}$ 中的消息 $m'$，方法是计算 $k'=c\oplus m'$，并将 $(m',k')$ 发送给验证者。验证者将错误地接受这个打开。我们称一次性密码本是一种\textbf{非绑定加密方案(non-binding encryption scheme)}，因为由它所派生而来的承诺方案是非绑定的。我们还能够证明，很多其他的加密方案也都是非绑定的。
\end{remark}

\begin{snote}[一个简单的拍卖。]
回到拍卖问题上，让我们看看如何使用一个安全的承诺方案 $\mathcal{C}=(C,V)$ 来实现一个简单可验证的密封投标拍卖，同时不需要依赖可信的拍卖行。每个竞拍者都在一个公开的公告板上（例如拍卖行网站上）发布他或她的投标承诺。承诺的隐藏属性确保，竞拍者的报价不会被泄露。承诺的绑定属性确保，竞拍者不能再修改报价。一旦所有的报价都被发布出来，拍卖行就会要求所有的竞拍者打开他们的承诺，然后决定赢家。所有的打开也都发布到公告板上，以便竞拍者可以审计拍卖。如果竞拍者在某个截止日期前没有打开他或她的承诺，他们的出价就会被丢弃。

当然，公告板需要被认证，以便每个人都能知道该承诺来自竞拍者，而不是其他什么伪装成竞拍者的人。这可以通过数字签名来实现，它是第\ref{chap:13}章的主题。我们还需要确保，一旦消息被发布到公告板上，就不能被删除，这样就能保证竞标不会被恶意地删除掉。

这种拍卖方案的一个缺点是，它迫使每个人，甚至是非赢家，公开透露他们的报价。这可以通过使用一种\emph{私人}密封投标拍卖方案来解决，在这种方案中，即使在拍卖结束后，投标仍然是秘密的。我们将在介绍更多密码学工具之后，于第\ref{chap:22}章构建这样的方案。

事实证明，即使我们使用了一个安全的承诺方案，上述的简单拍卖方案也可能是不安全的。让我们先用抗碰撞性来构造两个安全的承诺方案，然后在本节末尾重新审视这个拍卖方案。
\end{snote}

\begin{snote}[一种来自抗碰撞性的承诺方案。]
在 \ref{sec:3-12} 节中，我们使用伪随机发生器构建了一种优雅的承诺方案。然而，这个承诺方案其实很难使用。现在，我们可以用抗碰撞哈希函数更优雅地实现承诺。

令 $H$ 是一个定义在 $(\mathcal{X},\mathcal{Y})$ 上的哈希函数，其中 $\mathcal{X}=\mathcal{M}\times\mathcal{R}$。这里，$\mathcal{M}$ 是承诺方案的消息空间，$\mathcal{R}$ 是一个有限的 nonce 空间，将被用于提供隐藏属性。对于 $m\in\mathcal{M}$，由哈希函数 $H$ 派生的承诺方案 $\mathcal{C}_H=(C,V)$ 定义如下：
\[
\begin{aligned}
C(m) & := \big\{o\overset{\rm R}\leftarrow\mathcal{R},\;\; c\leftarrow H(m,o),\;\; \text{输出}\; (c,o)\big\}\\
V(m,c,o) &:= \big\{ \text{如果}\; c=H(m,o),\;\text{则输出}\; \mathsf{accept} \big\}
\end{aligned}
\]
为了论证这是一个安全的承诺方案，我们需要哈希函数 $H$ 满足两个属性。
\begin{itemize}
	\item 首先，如果 $H$ 是抗碰撞的，$\mathcal{C}_H$ 就是一个绑定的承诺。这是很直接的：如果一个有效对手 $\mathcal{A}$ 能够打破绑定属性，它就能立即制造出一个 $H$ 的碰撞。事实上，假设 $\mathcal{A}$ 输出两个数对 $(m_1,o_1)$ 和 $(m_2,o_2)$，其中 $m_1\neq m_2$，但 $V(m_1,c,o_1)=V(m_2,c,o_2)=\mathsf{accept}$，其中 $c$ 是某个承诺序列。那么，$H(h_1,o_1)=c=H(m_2,o_2)$ 就是一个 $H$ 的碰撞。因为该绑定属性取决于计算性假设，我们就称 $\mathcal{C}_H$ 是\textbf{计算性绑定的}。
	\item 其次，对于隐藏属性，我们希望 $H$ 满足某种特定的统计属性。如果对于所有的 $m_1,m_2\in\mathcal{M}$，分布 $\{H(m_1,o)\}$ 与分布 $\{H(m_2,o)\}$ 是统计上不可区分的，其中 $o\overset{\rm R}\leftarrow\mathcal{R}$，我们就称 $H$ 是\textbf{输入隐藏(input hiding)}的。如果 $H$ 是输入隐藏的，那么任何对手 $\mathcal{A}$——甚至是无界的对手——都无法破坏承诺方案 $\mathcal{C}_H$ 的语义安全性。我们说，该承诺方案是\textbf{无条件隐藏(unconditionally hiding)}的。
\end{itemize}
我们认为，如果集合 $\mathcal{R}$ 足够大，标准的抗碰撞哈希函数就是输入隐藏的。例如，对于 SHA256 来说，取 $R=\{0,1\}^{512}$ 应该是足够的。这就给出了一种基于 SHA256 构建安全且实用的承诺方案的方法。

我们注意到，\ref{sec:3-12} 节中提出的承诺方案是无条件绑定和计算隐藏的，这与我们在这里建立的方案正好相反。
\end{snote}

\begin{snote}[一种同态的承诺方案。]
让我们构建另一个承诺方案，这次，承诺方案有一个额外的属性。这个承诺方案的消息空间是 $\mathbb{Z}_q$，其中 $q>1$ 是某个整数。我们需要两个哈希函数：$H_1$ 定义在 $(\mathcal{R},\mathcal{Y})$ 上，$H_2$ 定义在 $(\mathcal{R},\mathbb{Z}_q)$ 上。对于 $m\in\mathbb{Z}_q$，由 $H_1$ 和 $H_2$ 派生的承诺方案 $\mathcal{C}_{H_1,H_2}=(C,V)$ 定义如下：
\[
\begin{aligned}
C(m) & := \big\{o\overset{\rm R}\leftarrow\mathcal{R},\;\; c_1\leftarrow H_1(o),\;\; c_2\leftarrow m+H_2(o),\;\; \text{输出}\; \big((c_1,c_2),\,o\big)\big\}\\
V\big(m,(c_1,c_2),o\big) &:= \big\{ \text{如果}\; c_1=H(o)\;\text{且}\; c_2=m+H_2(o),\;\text{则输出}\; \mathsf{accept} \big\}
\end{aligned}
\]
和之前一样，为了论证这是一个安全的承诺方案，我们需要哈希函数 $H_1$ 和 $H_2$ 满足两个属性。
\begin{itemize}
	\item 首先，如果 $H_1$ 是抗碰撞的，$\mathcal{C}_{H_1,H_2}$ 就是一个绑定的承诺。为了了解原因，假设一个有效对手 $\mathcal{A}$ 能够打破绑定属性。那么 $\mathcal{A}$ 必须输出两个数对 $(m_1,o_1)$ 和 $(m_2,o_2)$，其中 $m_1\neq m_2$，但 $V(m_1,c,o_1)=V(m_2,c,o_2)=\mathsf{accept}$，其中 $c=(c_1,c_2)$ 是某个承诺序列。但是此时，$H(o_1)=c_1=H(o_2)$ 是一个 $H$ 的碰撞。我们需要论证 $o_1\neq o_2$，但这一定是正确的，因为 $m_1+H_2(o_1)=c_2=m_2+H_2(o_2)$。因此，如果 $o_1=o_2$，我们就有 $m_1=m_2$，而这是不被允许的。
	\item 其次，对于隐藏属性，我们再次希望 $(H_1,H_2)$ 满足某种特定的统计属性。如果对于 $o\overset{\rm R}\leftarrow\mathcal{R}$ 和 $r\overset{\rm R}\leftarrow\mathbb{Z}_q$，分布 $\big(H_1(o),H_2(o)\big)$ 与分布 $\big(H_1(o),r\big)$ 是统计上不可区分的，我们就说 $(H_1,H_2)$ 是\textbf{相容(compatible)}的。如果 $(H_1,H_2)$ 是相容的，消息 $m\in\mathbb{Z}_q$ 就是用一个完美的一次性密码本隐藏的，因此该方案是无条件隐藏的。
\end{itemize}
当 $q<2^{256}$，$\mathcal{R}=\{0,1\}^{768}$ 时，我们可以假设函数 $H_1(x):=\mathrm{SHA256}(1\,\Vert\,x)$，$H_2(x):=\mathrm{SHA256}(2\,\Vert\,x) \bmod q$ 是相容的。当然，$H_1$ 也被认为是抗碰撞的。因此，我们可以由SHA256 得到第二个承诺方案。

\vspace{5pt}

这个新的安全承诺方案有一个有趣的属性：令 $c=(c_1,c_2)$ 是一条消息 $m\in\mathbb{Z}_q$ 的承诺，并令 $\delta\in\mathbb{Z}_q$。那么 $c':=(c_1,c_2+\delta)$ 就是对消息 $(m+\delta)\in\mathbb{Z}_q$ 的承诺。换句话说，任何人都可以将对 $m$ 的承诺转化为对 $(m+\delta)$ 的承诺，而且不需要对 $m$ 有任何了解。具有这种性质的承诺方案被称为\textbf{同态承诺方案(homomorphic commitment scheme)}。

这有什么用呢？对于某些应用来说，同态属性是一个福音，而对于其他应用来说，它是一个诅咒。我们将在 \ref{sec:12-9} 节看到同态承诺的正面应用。现在，让我们先来看一个负面的应用。

\vspace{5pt}

回顾一下本节开始时介绍的拍卖方案。在该方案中，即使承诺方案是安全的，同态属性也会导致系统的完全破坏。让我们来看看这种攻击。

假设 Alice 为她对花瓶的出价 $b\in\mathbb{Z}_q$ 提交了一个承诺 $c$。Bob 真的很想要这个花瓶，并且愿意比 Alice 多出一小笔钱。不幸的是，Bob 并不知道 Alice 打算出多少价。但 Bob 有办法作弊。一旦 Alice 的承诺 $c$ 被发布到公告版上，Bob 就可以利用同态性为值 $b+1\in\mathbb{Z}_q$ 构造一个新的承诺 $c'$。这就让 Bob 能确保他在拍卖中击败 Alice（除非 $b=q-1$，但我们可以假设 $q$ 足够大，这样这种情况就不会发生）。一旦 Alice 公开她的承诺 $c$ 的打开值，Bob 就获取到了他所需的所有东西，这些东西能帮助他公布他的承诺 $c'$ 的打开值。

即使根据定义 \ref{def:8-8}，承诺方案 $\mathcal{C}_{H_1,H_2}$ 是安全的，上述攻击也是可能发生的。一个潜在的防御措施是要求每次打开都必须使用互不相同的打开序列 $o$。但是，拍卖行首先需要意识到这种攻击的存在，才会知道检查这一点是有必要的。

为了完全避免这个问题，拍卖行需要一个具备更强安全属性的承诺方案。这种所需的属性被称为\textbf{不易控制性(non-malleability)}，[52] 定义和研究了这一属性。有趣的是，当 $H$ 被建模为一个随机预言机，并且其范围 $\mathcal{Y}$ 足够大时，第一个承诺方案 $\mathcal{C}_H$ 可以被证明是不易控制的。
\end{snote}