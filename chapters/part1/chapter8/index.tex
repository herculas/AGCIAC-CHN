\chapter{来自抗碰撞哈希的消息完整性}\label{chap:8}

在上一章中，我们讨论了通用哈希函数 (UHF)，并且展示了如何使用通用哈希函数来构建 MAC。回顾一下，UHF 是\emph{带密钥}的哈希函数，只要密钥被秘密地保存，找到哈希的碰撞就是困难的。

在本章中，我们将研究\emph{无密钥}的哈希函数，对于它们来说，找到哈希碰撞仍然是困难的。非正式地说，一个无密钥函数就是一个可有效计算的，描述完全公开的函数。它没有任何密钥，并且任何人都可以评估该函数。令 $H$ 是一个无密钥哈希函数，它将某个大的消息空间 $\mathcal{M}$ 上的元素哈希为某个小的摘要空间 $\mathcal{T}$ 上的元素。与上一章一样，当：
\[
H(m_0)=H(m_1)
\quad\text{and}\quad
m_0\neq m_1
\]
时，我们就称两条消息 $m_0,m_1\in\mathcal{M}$ 是函数 $H$ 的一个\textbf{碰撞(collision)}。非正式地说，如果找到一个 $H$ 的碰撞是困难的，我们就称函数 $H$ 是\textbf{抗碰撞的(collision resistant)}。由于摘要空间 $\mathcal{T}$ 比消息空间 $\mathcal{M}$ 要小得多，所以我们知道，其实是存在许多这样的碰撞的。尽管如此，如果 $H$ 是抗碰撞的，那么实际上找到一个碰撞的数对 $m0,m1$ 应该是很困难的。我们将在下一节中给出一个更精确的定义。

在这一章中，我们将构造抗碰撞的函数，并介绍一些它的应用。为了举一个抗碰撞函数的例子，我们会介绍一个美国联邦标准，称作安全哈希算法标准，简称为 SHA。SHA 标准描述了一些能够提供不同程度的抗碰撞性能的哈希函数。例如，\textbf{SHA256} 是一个能将长消息哈希成 $256$ 比特摘要的函数。我们相信，找到 SHA256 的碰撞是很困难的。

抗碰撞哈希函数有许多应用。我们在这里简要介绍两个这样的应用，并在本章的稍后部分给出更多细节。本书的其他部分还会涉及到更多的应用。

\begin{snote}[扩展密码学原语。]
抗碰撞性的一个重要应用是它能够将为短输入建立的原语扩展成为更长输入建立的原语。我们举一个 MAC 构造作为例子。假设我们被给定一个 MAC 系统 $\mathcal{I}=(S,V)$，它只能认证短的消息，比如说 $256$ 比特长的消息。我们想扩展 MAC 的域，使其能够验证更长的消息输入。抗碰撞哈希给出了一个非常简单的解决方案。为了计算某个长消息 $m$ 的 MAC，我们可以先对 $m$ 进行哈希，然后将 $S$ 应用在所得到的短摘要上，如图 \ref{fig:8-1} 所示。换句话说，我们实际上定义了一个新的 MAC 系统 $\mathcal{I}=(S',V')$，其中 $S'(k,m):=S\big(k,H(m)\big)$。MAC 验证的工作方式与此类似，我们首先对消息进行哈希，然后验证摘要的标签。

显然，如果找到 $H$ 的碰撞是容易的，这种先哈希后 MAC 的构造就不安全了。如果对手能找到两条长消息 $m_0$ 和 $m_1$ 使得 $H(m_0)=H(m_1)$，那么它就可以用选择消息攻击来伪造标签。假设 $m_0$ 是一条无害的消息，但 $m_1$ 是恶意的内容，比如一个被病毒感染的程序。对手会请求消息 $m_0$ 的标签，并得到一个标签 $t$ 作为应答。那么这个数对 $(m_0,t)$ 就是一个有效的消息-标签对，但是数对 $(m_1,t)$ 同样也是有效的。因此，对手能够为 $m_1$ 伪造一个标签，这就破坏了 MAC。更糟糕的是，有效的标签可能会欺骗用户运行病毒。这个论证表明，抗碰撞性是这种先哈希后 MAC 构造满足安全性的必要条件。在本章的稍后部分，我们将证明抗碰撞性实际上足以证明安全性。

\begin{figure}
	\centering
	\input{figures/chapter8/fig1.tex}
	\caption{先哈希后 MAC 构造}
	\label{fig:8-1}
\end{figure}

先哈希后 MAC 构造看起来与前一章（\ref{sec:7-3} 节）所讨论的 PRF(UHF) 组合类似。这两种方法都从迥异的构件中构建起看起来相似的 MAC。它们的主要区别在于，抗碰撞哈希可以扩展任何 MAC 的输入域。另一方面，UHF 只能扩展一种类型非常特殊的 MAC（即 PRF）的域。我们将在练习 \ref{exer:7-4} 中作进一步说明。另一个区别是，先哈希后 MAC 方法中的密钥与底层 MAC 中的密钥是完全相同的。相对地，PRF(UHF) 方法通过添加一个 UHF 密钥来扩展底层 PRF 的秘钥。

当我们希望在多个密钥 $k_1,\dots,k_n$ 下计算单个消息 $m$ 的标签时，先哈希后 MAC 构造比 PRF(UHF) 表现得更好。此时，我们希望对所有的 $i=1,\dots,n$ 计算 $S'(k_i,m)$。当我们需要为一个可被多个用户读取的磁盘文件提供完整性保证时，就会出现这种情况。文件头部中包含为每个用户准备的完整性标签，这样，每个用户都可以用自己的 MAC 密钥来验证完整性。使用先哈希后 MAC 构造，我们只需要计算一次 $H(m)$，然后就能从这一个哈希中快速推导出 $n$ 个标签。但在 PRF(UHF) MAC 下，UHF 取决于密钥 $k_i$，因而，我们需要对整个消息进行 $n$ 次重新哈希，即对每个用户都需要进行一次。关于这个问题的更多细节，请参见练习 \ref{exer:6-4}。
\end{snote}

\begin{snote}[文件完整性。]
抗碰撞性的另一个应用是文件的完整性，我们也曾在第\ref{chap:6}章的前言中讨论过。考虑 $n$ 个不经常变化的一组关键文件，比如某些操作系统文件。我们需要一种方法来验证这些文件没有被一些恶意代码或软件篡改。要做到这一点，我们需要少量的只读存储器，恶意软件可以读取它们，但无从篡改。一个例子是一种 U 盘，它有一个物理开关，当把它拨到``只读"位置时，它就是一个只读存储器。我们可以在只读存储器中存放这 $n$ 个关键文件的哈希值，这样，这个存储区域就只包含 $n$ 个短哈希值。然后，我们可以通过重新哈希文件 $F$，并将得到的哈希值与存储在只读存储器中的哈希值进行比较来检查 $F$ 的完整性。如果发现不匹配，系统就会宣布文件 $F$ 被破坏了。\emph{TripWire} 恶意软件保护系统就使用这种机制来保护关键的系统文件。

为了使这种完整性机制是安全的，哈希函数 $H$ 应该满足什么属性？令 $F$ 是一个受该系统保护的文件。由于恶意软件不能修改只读存储器的内容，它修改 $F$ 而不被发现的唯一途径，就是找到另一个文件 $F'$，使得 $H(F)=H(F')$。用 $F'$ 替换 $F$ 将不会被这个哈希系统发现。然而，如果 $H$ 是抗碰撞的，找到这样的 $F'$ 就是很困难的。因此，抗碰撞性意味着，恶意软件无法在不被哈希检测到的情况下改变 $F$。

这个系统将所有文件的哈希值存储在只读存储器中。当有许多文件需要保护时，所需的只读存储器的数量可能变得相当大。我们可以通过将整个文件的哈希值视为存储在磁盘上的另一个文件，表示为 $F_H$，来大大减少所需的只读存储器的大小。我们将 $F_H$ 的哈希值存储在只读存储器中，如图 \ref{fig:8-2} 所示，所以现在只读存储器只包含一个哈希值。为了验证某个文件 $F$ 的完整性，我们首先哈希 $F_H$ 的内容，并将其结果与只读存储器中的值进行比较，以验证文件 $F_H$ 的完整性。然后，我们哈希 $F$，并将结果与存储在 $F_H$ 中的相应哈希值相比较，以验证 $F$ 的完整性。我们将在 \ref{sec:8-9} 节介绍一个使用认证树的更高效的解决方案。

\begin{figure}
	\centering
	\input{figures/chapter8/fig2.tex}
	\caption{使用小的只读存储器来保证文件完整性}
	\label{fig:8-2}
\end{figure}

在第\ref{chap:6}章的前言中，我们介绍了一个基于 MAC 的文件完整性系统。该系统将每个文件的标签与该文件一起存储起来。我们还需要少量的\emph{机密存储}来存储用户的机密 MAC 密钥。这个密钥在每次验证文件完整性时都需要被使用。相比之下，当使用抗碰撞哈希时，没有任何机密，也不需要任何机密存储。相对地，我们只需要少量的只读存储器来储存文件的哈希。一般来说，只读存储比秘密存储更容易建立。因此，抗碰撞性似乎更适合于这种特殊的应用。在第\ref{chap:13}章中，我们将为这个问题提供一个更优秀的解决方案，它将使用数字签名，并且不需要任何只读存储或在线的机密存储。
\end{snote}

\begin{snote}[不依赖抗碰撞的安全性。]
通过使用一些随机比特来扩展哈希函数的输入，我们可以用一个较弱的抗碰撞概念来证明上述两种应用的安全性，这个概念称为\textbf{目标抗碰撞性(target collision resistance)}，简称为 TCR。我们将在 \ref{subsec:8-11-2} 小节中展示如何将 TCR 用于文件完整性和扩展密码学原语的场景。这种方案的缺点是所产生的标签比从抗碰撞哈希得到的标签要来的长。因此，尽管从原则上说，我们常常可以避免依赖抗碰撞，但所产生的系统却往往并不那么有效。
\end{snote}

\input{chapters/part1/chapter8/section1}
\input{chapters/part1/chapter8/section2}
\input{chapters/part1/chapter8/section3}
\input{chapters/part1/chapter8/section4}
\input{chapters/part1/chapter8/section5}
\input{chapters/part1/chapter8/section6}
\input{chapters/part1/chapter8/section7}
\input{chapters/part1/chapter8/section8}
\input{chapters/part1/chapter8/section9}
\input{chapters/part1/chapter8/section10}
\input{chapters/part1/chapter8/section11}
\input{chapters/part1/chapter8/section12}
\input{chapters/part1/chapter8/section13}
\input{chapters/part1/chapter8/section14}