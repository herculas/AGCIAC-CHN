\section{案例研究：针对 SSH 中非原子性解密的一种攻击}\label{sec:9-9}

SSH（安全 shell）是一种流行的命令行工具，用于与远程主机安全地交换信息。SSH 旨在取代（不安全的）UNIX 工具，比如 telnet、rlogin、rsh 和 rcp。在本节中，我们将描述 SSH 中所使用的一个旧密码套件的一个诱人的漏洞。这个漏洞是一个绝佳的例子，它能够说明，当解密不是原子性的时候，即当解密算法在验证完整条记录的完整性之前就开始释放解密记录的片段时，会出现什么问题。

首先，我们介绍一下历史。第一个版本的 SSH 被称为 SSHv1，它于 1995 年推出。不久之后，有人指出 SSHv1 存在严重的设计缺陷。
\begin{itemize}
	\item 最显著的问题是，SSHv1 会计算明文的循环冗余校验 (Cyclic Redundancy Check, CRC)，并将产生的校验和明文附加到密文后，以此来提供数据完整性。CRC 是一种简单的无密钥线性函数——所以，这不仅直接泄露了关于明文的信息，还使得破坏完整性变得相当容易。
	\item 另一个问题是对 CBC 模式加密的不正确使用。SSHv1 总是将 CBC 初始值 (IV) 置为 $0$。因此，当两个 SSHv1 数据包含有相同的前缀时，攻击者就能立即认识到这一点。回顾一下，为了确保 CPA 安全性，IV 必须是随机选出的。
	\item 还有一个问题，在 SSHv1 中，同一个加密密钥会被用于两个方向的加密（即用户到服务器和服务器到用户）。
\end{itemize}
为了纠正这些问题，一个修订后的不兼容协议 SSHv2 于 1996 年被发布出来。在 SSHv2 中，会话设置的结果是两个密钥：用于加密用户到服务器数据的 $k_{u\to s}$，以及用于加密相反方向数据的 $k_{s\to u}$。这里，我们只关注 SSHv2 是如何利用这些密钥进行消息传输的。

\begin{figure}
  \centering
  \input{figures/chapter9/fig3.tex}
  \caption{一个 SSHv2 数据包}
  \label{fig:9-3}
\end{figure}

\begin{snote}[SSHv2 加密。]
下面，我们考察 SSHv2 中所使用的一个旧密码套件。SSHv2 使用先加密后 MAC 范式（见练习 \ref{exer:9-10}）来将一个 CPA 安全的密码和一个安全的 MAC 结合起来，以试图构建一个安全的 AEAD 密码。具体来说，SSHv2 加密工作如下（另见图 \ref{fig:9-3}）：
\begin{enumerate}
	\item \textbf{填充。}用\emph{随机}字节填充明文，使明文：
	\[
	\texttt{plaintext}
	:=
	\texttt{packet-length}
	\;\Vert\;
	\texttt{pad-length}
	\;\Vert\;
	\texttt{message}
	\;\Vert\;
	\texttt{pad}
	\]
	的总长度等于密文分组长度的整数倍（对于 AES 则为 $16$ 字节）。\texttt{pad-length} 可以是 $4$ 字节到 $255$ 字节之间的任何值。\texttt{packet-length} 字段衡量的是数据包的长度，以字节为单位，不包括完整性标签或 \texttt{packet-length} 字段本身。
	\item \textbf{加密。}使用随机 CBC 模式下的 AES 对图 \ref{fig:9-3} 中的灰色区域进行加密，视加密方的身份，使用 $k_{u\to s}$ 或者 $k_{s\to u}$。SSHv2 使用练习 \ref{exer:5-13} 中描述的随机化 CBC 模式加密的缺陷版本。
	\item \textbf{MAC。}在一个 \texttt{sequence-number} 和图 \ref{fig:9-3} 中粗框内的明文数据上计算 MAC。这里，\texttt{sequence-\allowbreak number} 是一个 $32$ 比特的序列号，它在第一个数据包中被初始化为 $0$，并在每个数据包后递增 $1$。SSHv2 可以选用许多 MAC 算法，但必须至少支持 HMAC-SHA1-160。
\end{enumerate}

当收到一个加密的数据包时，解密算法的工作原理如下：首先，它使用 $k_{u\to s}$ 或 $k_{s\to u}$ 解密 \texttt{packet-}\allowbreak\texttt{length} 字段。接下来，它再从网络上读取与该字段值等长的数据包，再加上完整性标签所需的额外字节。然后，它解密密文的其他部分，并验证完整性标签的有效性。如果标签是有效的，它就移除填充并返回明文消息。

尽管 SSH 使用的先加密后 MAC 范式通常是不安全的，但我们会在练习 \ref{exer:9-10} 中表明，对于某些密码和 MAC 的组合，包括 SSHv2 中所要求的组合，先加密后 MAC 确实能够提供认证加密。
\end{snote}

\begin{snote}[加密长度以隐藏 SSH 的边界。]
SSHv2 的一个有趣的方面在于，它的加密算法也会加密 \texttt{packet-length} 字段，如图 \ref{fig:9-3} 所示。这样做的动机是为了确保，如果将一系列加密 SSH 数据包作为字节流在不安全的网络上传输，那么窃听者应该无法确定发送的数据包的数量，或者它们的长度。这是为了挫败某些试图从明文长度推断其中所包含的信息的流量分析攻击。

在连续的加密消息之间隐藏消息边界超出了认证加密的要求范围。事实上，许多安全的 AEAD 模式都不能提供这种水平的机密性。例如，TLS 1.0 会将每条记录的长度以明文形式发送，这让连续的加密记录之间的边界很容易被发现。Boldyreva，Degabriele，Paterson 和 Stam 定义了一种能够确保边界隐藏的强化认证加密，并且提出了一些满足该定义的构造 \cite{boldyreva2012security}。
\end{snote}

\begin{snote}[针对非原子性解密的攻击。]
注意到，CBC 解密分为两步进行：首先解密 $32$ 比特的 \texttt{packet-length} 字段，并依此决定再从网络中读取多少字节。接下来，解密 CBC 密文的其余部分。

一般来说，AEAD 密码的设计并没有考虑这种使用方法：在整个密文解密过程完成之前，明文数据不应该被使用；然而在 SSHv2 中，在完整性被验证之前，长度字段已经被解密和使用了。

可以用它来攻击 SSHv2 吗？一种优雅的攻击揭示了如何利用这种非原子性解密来完全破坏机密性 \cite{albrecht2009plaintext}。下面，我们只关注整体的想法，忽略具体的实现细节。假设一个攻击者截获了一个 $16$ 字节的密文分组 $c$，并且想要知道 $c$ 解密后的前 $4$ 字节。它通过下面这种滥用解密过程的方式来实现这一目的：首先，它将密文分组 $c$ 发送给服务器，\emph{就好像}它是一个新的加密数据包的第一个分组一样。服务器会解密 $c$，并将前四个字节解释为长度字段 $\ell$。现在，在检查完整性标签之前，服务器期望先从网络上读取 $\ell$ 字节的数据。攻击者可以慢慢地向服务器发送任意的字节，一次一个，并在每个字节后都等待一段时间，看看服务器是否给出了响应。一旦服务器读取了 $\ell$ 个字节，它就会尝试验证它所收到的字节的完整性标签，这很可能会导致服务器发回一条报错消息。因此，一旦读取了 $\ell$ 个字节，攻击者就能收到一条报错消息。这就等于告诉了攻击者 $\ell$ 的值，而这就是它想要的。

在实践中，发动这样的攻击可能会面临很多复杂的问题。然而，它仍然能够表明，在验证完整性之前使用解密数据（在本例中为长度字段）是极其危险的。如上所述，读者可以参考 \cite{boldyreva2012security} 了解安全隐藏数据包长度的加密方法。
\end{snote}

\begin{snote}[一种巧妙的 SSH 流量分析攻击。]
SSHv2 会为用户的每次击键发送一个网络数据包。这就带来了 \cite{song2001timing} 中报告的一种有趣的流量分析攻击。假设一个网络窃听者知道用户正在他或她的键盘上输入口令。通过测量连续数据包之间的时间差，窃听者就能获得连续击键的计时信息。这就暴露了关于用户口令的信息：连续击键之间较长的时间差就能够暴露相关按键在键盘上的位置信息。作者表明，这种信息可以大大加快离线口令字典攻击的速度。更糟糕的是，口令数据包很容易被甄别出来，因为应用程序通常会在输入口令时关闭回声，这样，口令数据包就不会从服务器产生回声数据包。

一些 SSH 实现通过注入随机定时的``假"消息来防御这个问题，它能使流量分析更加困难。当消息的第一个字节被置为 \texttt{SSH\_MSG\_IGNORE} 时，该消息就是一条假消息，它会被接收方忽略掉。由于加密，窃听者是无法区分假记录和真实记录的。
\end{snote}