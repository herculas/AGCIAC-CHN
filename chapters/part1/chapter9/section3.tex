\section{作为抽象接口的加密}\label{sec:9-3}

为了深入理解认证加密的定义，我们表明，它准确地捕捉了一个直观的概念，即作为一个\emph{抽象接口(abstract interface)}的安全加密。AE 安全性意味着，对这种接口的实际实现可以被一个理想化实现取代。而在这个理想化实现中，消息实际上是从发送方直接跳变到接收方的，根本不需要经过任何网络通信（甚至是任何加密方式的通信）。下面，我们更系统地阐述这一想法。

假设发送方 $S$ 和接收方 $R$ 正在使用某个任意的、基于互联网的系统（比如游戏、拍卖、银行等等）。另外，我们假设 $S$ 和 $R$ 已经共享了一个随机的加密密钥 $k$。在协议过程中，$S$ 会向 $R$ 发送消息 $m_1,m_2,\dots$ 的加密。消息 $m_i$ 由 $S$ 所使用协议的逻辑决定，我们不管它到底是什么。我们可以想象，$S$ 将消息 $m_i$ 放在它的``发件箱"中，而发件箱的具体工作细节与 $S$ 无关。当然，我们还是能知道 $S$ 的发件箱中会发生什么：$m_i$ 会被 $k$ 加密成 $c_i$，而后者会通过一条电线被发送至 $R$。

在接收侧，当一条密文 $\hat{c}$ 抵达电线位于 $R$ 的那一端时，它就会被 $k$ 解密。如果解密的结果是一条消息 $\hat{m}\neq\mathsf{reject}$，这条消息就会被放到 $R$ 的``收件箱"中。每当有消息出现在 $R$ 的收件箱中，$R$ 都可以读取这条消息，并根据它的协议逻辑对消息进行处理，而不必担心消息是如何到达的。

攻击者可能试图以多种方式破坏 $S$ 和 $R$ 之间的通信：
\begin{itemize}
	\item 第一，攻击者可能会丢弃、重排或重放 $S$ 所发送的密文。
	\item 第二，攻击者可能会篡改由 $S$ 发送的密文，或注入一些凭空创建的新密文。
	\item 第三，攻击者可能掌握了由 $S$ 发送的某些消息的部分知识，或者甚至能够影响其中一些消息的选择。
	\item 第四，通过观察 $R$ 的行为，攻击者可能会收集到经过 $R$ 处理的某些消息的部分知识。即使是关于交付给 $R$ 的密文是否被拒绝的知识也可能是有用的。
\end{itemize}

在描述了一个抽象的加密接口及其实现之后，我们下面描述这个接口的一种\emph{理想实现(ideal implementation)}，它以一种直观的方式捕捉到了认证加密所提供的安全性保证。当 $S$ 将 $m_i$ 放到它的``发件箱"中时，理想实现现在不再对 $m_i$ 进行加密，而是加密一条与 $m_i$ 无关的假消息 $\mathit{dummy}_i$（它们的长度应当相同），以此来创建一条密文 $c_i$。因此，$c_i$ 可以被视作是 $m_i$ 的一个``把手"，但不包含任何（除了长度之外）的关于 $m_i$ 的信息。当 $c_i$ 到达 $R$ 时，对应的消息 $m_i$ 被神奇地从 $S$ 的发件箱复制到 $R$ 的收件箱中。如果一条密文到达 $R$，但不在先前生成的 $c_i$ 中，理想实现就会丢弃它。

这个理想实现其实只是一种思想实验。它显然不能以任何有效的方式在物理上实现（如果不先发明远程传输的话）。然而，正如我们将要论证的那样，如果底层密码 $\mathcal{E}$ 提供认证加密，理想实现——就所有实际目的而言——都等同于真正的实现。因此，协议设计者不需要担心真实实现的任何细节，或者加密定义的细微差别：他可以假装他正在使用抽象的加密接口及其理想实现，其中的密文都只是把手，而消息都会神奇地从 $S$ 跳变到 $R$。

请注意，就算是在理想实现中，攻击者仍然可能丢弃、重排或重放密文，而这些行为将导致对应的消息被丢弃、重排或重放。使用序列号和缓冲区处理这些问题并不困难，但这些工作要留给更高层的协议。

\vspace*{10pt}

下面，我们非正式地论证，当 $\mathcal{E}$ 能够提供认证加密时，现实世界中的实现与理想实现是没有任何区别的。该论证分三步进行。我们先从真实的实现开始，在每一步中，我们都会做一些轻微的修改。
\begin{itemize}
	\item 首先，我们对 $R$ 的收件箱的真实实现进行修改，如下所示。当一条密文 $\hat{c}$ 到达 $R$ 那一端时，由 $S$ 先前生成的密文列表 $c_1,c_2,\dots$ 会被扫描，如果 $\hat{c}=c_i$，相应的消息 $m_i$ 就会被神奇地从 $S$ 的发件箱复制到 $R$ 的收件箱中，而不需要实际运行解密算法。
	
	$\mathcal{E}$ 的正确性属性保证，修改后的行为与真正实现完全相同。
	\item 其次，我们再次修改 $R$ 的收件箱上的实现，此时，如果一条密文 $\hat{c}$ 到达 $R$ 那一端，但不在 $S$ 所生成的密文列表中，该实现就会丢弃 $\hat{c}$。
	
	对手能够区分这种修改和第一种修改的唯一方法是，它创造一条不会被拒绝，但不是由 $S$ 产生的密文。但这是不可能的，因为 $\mathcal{E}$ 有密文完整性。
	\item 第三，我们修改 $S$ 的发件箱的实现，用对 $\mathit{dummy}_i$ 的加密取代对 $m_i$ 的加密。$R$ 的收件箱的实现仍与第二次修改相同。请注意，解密算法在第二和第三种修改中都没有被使用。因此，一个能够区分这个修改和第二个修改的对手就可以被用来直接破解 $\mathcal{E}$ 的 CPA 安全性。因此，由于 $\mathcal{E}$ 是 CPA 安全的，这两种修改就是不可区分的。
\end{itemize}

由于第三个修改与理想实现相同，我们可以看到，从对手的角度来看，真实实现和理想实现是无法区分的。

我们没有考虑到的一个技术问题是，存在这样一种可能性，即由 $S$ 产生的 $c_i$ 不是唯一的。当然，如果我们要把 $c_i$ 看作是理想实现中的把手，唯一性似乎是一个基本属性。事实上，CPA 安全意味着，在理想实现中，生成的 $c_i$ 是唯一的概率是压倒性的，参见练习 \ref{exer:5-12}。